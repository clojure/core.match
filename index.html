<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>clojure.core.match - core.match 1.1.1-SNAPSHOT API documentation</title>
    <link rel="icon" href="static/favicon.png" />
    <link rel="shortcut icon" href="static/favicon.png" />
    <link rel="stylesheet" href="static/clojure.css" type="text/css" media="all" />
    <link rel="stylesheet" href="static/wiki.css" type="text/css" media="all" />
    <link rel="stylesheet" href="static/internal.css" type="text/css" media="all" />
    <style>.menuWrapper{height: 36px;}</style>
  </head>
<!--
This document was auto-generated from the source by the clojure autodoc system.
To report errors or ask questions about the overall documentation structure, formatting,
etc., contact Tom Faulhaber (google mail name: tomfaulhaber).
For errors in the documentation of a particular namespace, contact the author of that
namespace.
-->
  <body>
    <div id="AllContentContainer">
      <div id="Header">
	<a href="index.html" id="Logo"><img src="static/clojure-icon.gif" width="100" height="100" alt="Clojure" /></a>
	<h1><a href="index.html" id="page-header" title="page header title">core.match API Reference</a></h1>
      </div>
      <div id="leftcolumn"><div style="text-align: center;"></div>
<div class="menu">
  <div class="WikiCustomNav WikiElement wiki">
    <span class="toc-header"><span id="project-name">core.match</span> <span id="version">1.1.1-SNAPSHOT</span> API</span><br />
    <ul>
      <li><a href="index.html" class="wiki_link">Overview</a></li>
      <li><a href="api-index.html" class="wiki_link">API Index</a></li>
    </ul>
    
    
    <a class="wiki_link" href="https://clojure.org">Clojure Home</a>
  </div>
</div>
</div>
      <div id="rightcolumn">
	<div id="Content">
	  <div class="contentBox"><div class="innerContentBox">
              <div class="wiki wikiPage" id="content_view">
                <div id="right-sidebar"><div id="toc">
  <h1 class="nopad">Table of Contents</h1>
  <div class="toc-section" style="margin-left: 1em;">
    <a style="margin-top: 3px;" href="#toc0">Overview</a>
    
  </div><div class="toc-section" style="margin-left: 1em;">
    <a style="margin-top: 3px;" href="#"></a>
    
  </div><div class="toc-section" style="margin-left: 1em;">
    <a style="margin-top: 3px;" href="#type-section">Types</a>
    <div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.match/AppPattern" class="toc-entry-anchor">AppPattern</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.match/BindNode" class="toc-entry-anchor">BindNode</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.match/FailNode" class="toc-entry-anchor">FailNode</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.match/GuardPattern" class="toc-entry-anchor">GuardPattern</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.match/LeafNode" class="toc-entry-anchor">LeafNode</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.match/LiteralPattern" class="toc-entry-anchor">LiteralPattern</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.match/MapKeyPattern" class="toc-entry-anchor">MapKeyPattern</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.match/MapPattern" class="toc-entry-anchor">MapPattern</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.match/OrPattern" class="toc-entry-anchor">OrPattern</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.match/PatternMatrix" class="toc-entry-anchor">PatternMatrix</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.match/PatternRow" class="toc-entry-anchor">PatternRow</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.match/PredicatePattern" class="toc-entry-anchor">PredicatePattern</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.match/RestPattern" class="toc-entry-anchor">RestPattern</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.match/SeqPattern" class="toc-entry-anchor">SeqPattern</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.match/SwitchNode" class="toc-entry-anchor">SwitchNode</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.match/VectorPattern" class="toc-entry-anchor">VectorPattern</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.match/WildcardPattern" class="toc-entry-anchor">WildcardPattern</a>
      
    </div>
  </div><div class="toc-section" style="margin-left: 1em;">
    <a style="margin-top: 3px;" href="#var-section">Vars and Functions</a>
    <div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.match/*match-lookup*" class="toc-entry-anchor">*match-lookup*</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.match/*no-backtrack*" class="toc-entry-anchor">*no-backtrack*</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.match/*recur-present*" class="toc-entry-anchor">*recur-present*</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.match/*syntax-check*" class="toc-entry-anchor">*syntax-check*</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.match/*vector-type*" class="toc-entry-anchor">*vector-type*</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.match/-&gt;AppPattern" class="toc-entry-anchor">-&gt;AppPattern</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.match/-&gt;BindNode" class="toc-entry-anchor">-&gt;BindNode</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.match/-&gt;FailNode" class="toc-entry-anchor">-&gt;FailNode</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.match/-&gt;GuardPattern" class="toc-entry-anchor">-&gt;GuardPattern</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.match/-&gt;LeafNode" class="toc-entry-anchor">-&gt;LeafNode</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.match/-&gt;LiteralPattern" class="toc-entry-anchor">-&gt;LiteralPattern</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.match/-&gt;MapKeyPattern" class="toc-entry-anchor">-&gt;MapKeyPattern</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.match/-&gt;MapPattern" class="toc-entry-anchor">-&gt;MapPattern</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.match/-&gt;OrPattern" class="toc-entry-anchor">-&gt;OrPattern</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.match/-&gt;PatternMatrix" class="toc-entry-anchor">-&gt;PatternMatrix</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.match/-&gt;PatternRow" class="toc-entry-anchor">-&gt;PatternRow</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.match/-&gt;PredicatePattern" class="toc-entry-anchor">-&gt;PredicatePattern</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.match/-&gt;RestPattern" class="toc-entry-anchor">-&gt;RestPattern</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.match/-&gt;SeqPattern" class="toc-entry-anchor">-&gt;SeqPattern</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.match/-&gt;SwitchNode" class="toc-entry-anchor">-&gt;SwitchNode</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.match/-&gt;VectorPattern" class="toc-entry-anchor">-&gt;VectorPattern</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.match/-&gt;WildcardPattern" class="toc-entry-anchor">-&gt;WildcardPattern</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.match/backtrack" class="toc-entry-anchor">backtrack</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.match/emit-matrix" class="toc-entry-anchor">emit-matrix</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.match/emit-pattern" class="toc-entry-anchor">emit-pattern</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.match/emit-pattern-for-syntax" class="toc-entry-anchor">emit-pattern-for-syntax</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.match/empty-rows-case" class="toc-entry-anchor">empty-rows-case</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.match/first-column-chosen-case" class="toc-entry-anchor">first-column-chosen-case</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.match/first-row-empty-case" class="toc-entry-anchor">first-row-empty-case</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.match/first-row-wildcards-case" class="toc-entry-anchor">first-row-wildcards-case</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.match/group-keywords" class="toc-entry-anchor">group-keywords</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.match/groupable?" class="toc-entry-anchor">groupable?</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.match/map-&gt;BindNode" class="toc-entry-anchor">map-&gt;BindNode</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.match/map-&gt;FailNode" class="toc-entry-anchor">map-&gt;FailNode</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.match/map-&gt;LeafNode" class="toc-entry-anchor">map-&gt;LeafNode</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.match/map-&gt;MapKeyPattern" class="toc-entry-anchor">map-&gt;MapKeyPattern</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.match/map-&gt;PatternMatrix" class="toc-entry-anchor">map-&gt;PatternMatrix</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.match/map-&gt;RestPattern" class="toc-entry-anchor">map-&gt;RestPattern</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.match/map-&gt;SwitchNode" class="toc-entry-anchor">map-&gt;SwitchNode</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.match/match" class="toc-entry-anchor">match</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.match/matchm" class="toc-entry-anchor">matchm</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.match/other-column-chosen-case" class="toc-entry-anchor">other-column-chosen-case</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.match/process-vars" class="toc-entry-anchor">process-vars</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.match/to-pattern-row" class="toc-entry-anchor">to-pattern-row</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.match/to-source" class="toc-entry-anchor">to-source</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.match/wildcards-and-duplicates" class="toc-entry-anchor">wildcards-and-duplicates</a>
      
    </div>
  </div><div class="toc-section" style="margin-left: 1em;">
    <a style="margin-top: 3px;" href="#"></a>
    
  </div><div class="toc-section" style="margin-left: 1em;">
    <a style="margin-top: 3px;" href="#clojure.core.match.java">clojure.core.match.java</a>
    <div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.match.java/bean-match" class="toc-entry-anchor">bean-match</a>
      
    </div>
  </div><div class="toc-section" style="margin-left: 1em;">
    <a style="margin-top: 3px;" href="#clojure.core.match.protocols">clojure.core.match.protocols</a>
    <div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.match.protocols/IMatchLookup" class="toc-entry-anchor">IMatchLookup</a>
      <div class="toc-subentry" style="margin-left: 1em;">
        <a href="#clojure.core.match.protocols/val-at" class="toc-subentry-anchor">val-at</a>
      </div>
    </div>
  </div><div class="toc-section" style="margin-left: 1em;">
    <a style="margin-top: 3px;" href="#clojure.core.match.regex">clojure.core.match.regex</a>
    <div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.match.regex/RegexPattern" class="toc-entry-anchor">RegexPattern</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.match.regex/-&gt;RegexPattern" class="toc-entry-anchor">-&gt;RegexPattern</a>
      
    </div><div class="toc-entry" style="margin-left: 1em;">
      <a href="#clojure.core.match.regex/map-&gt;RegexPattern" class="toc-entry-anchor">map-&gt;RegexPattern</a>
      
    </div>
  </div>
</div>
</div>
                <div id="content-tag"><h1 id="overview">API for <span id="clojure.core.match">clojure.core.match</span>
  - <span id="header-project">core.match</span> <span id="header-version">1.1.1-SNAPSHOT</span><span id="header-status-block"> (<span id="header-status">in development</span>)</span>
  </h1>

<br />Full namespace name: <span id="long-name">clojure.core.match</span>
<p></p>
<h2>Overview</h2>
<div id="home-page">Project home page is <a href="https://github.com/clojure/core.match/">https://github.com/clojure/core.match/</a></div>
<pre id="namespace-docstr"></pre>


<br />


<div id="type-section">
  <p></p>
  <h2>Types</h2>
  <div id="type-entry">
    <br />
    <hr />
    <h2 id="clojure.core.match/AppPattern">AppPattern</h2>
    <span id="type-type">type</span><br />
    <pre id="type-docstr"></pre>
    Fields: <span id="type-fields">[p form _meta]</span><br />
    Protocols: <span id="type-protocols"><a href="clojure.core.match-api.html#clojure.core.match.protocols/ISpecializeMatrix">clojure.core.match.protocols/ISpecializeMatrix</a></span><br />
    Interfaces: <span id="type-interfaces">clojure.core.match.protocols.IPseudoPattern, clojure.lang.ILookup, clojure.lang.IObj</span><br />
  </div><div id="type-entry">
    <br />
    <hr />
    <h2 id="clojure.core.match/BindNode">BindNode</h2>
    <span id="type-type">record</span><br />
    <pre id="type-docstr"></pre>
    Fields: <span id="type-fields">[bindings node]</span><br />
    Protocols: <span id="type-protocols"><a href="clojure.core.match-api.html#clojure.core.match.protocols/INodeCompile">clojure.core.match.protocols/INodeCompile</a></span><br />
    Interfaces: <span id="type-interfaces">clojure.lang.IHashEq, clojure.lang.IKeywordLookup, clojure.lang.ILookup, clojure.lang.IObj, clojure.lang.IPersistentMap, java.io.Serializable, java.util.Map</span><br />
  </div><div id="type-entry">
    <br />
    <hr />
    <h2 id="clojure.core.match/FailNode">FailNode</h2>
    <span id="type-type">record</span><br />
    <pre id="type-docstr"></pre>
    Fields: <span id="type-fields">[]</span><br />
    Protocols: <span id="type-protocols"><a href="clojure.core.match-api.html#clojure.core.match.protocols/INodeCompile">clojure.core.match.protocols/INodeCompile</a></span><br />
    Interfaces: <span id="type-interfaces">clojure.lang.IHashEq, clojure.lang.IKeywordLookup, clojure.lang.ILookup, clojure.lang.IObj, clojure.lang.IPersistentMap, java.io.Serializable, java.util.Map</span><br />
  </div><div id="type-entry">
    <br />
    <hr />
    <h2 id="clojure.core.match/GuardPattern">GuardPattern</h2>
    <span id="type-type">type</span><br />
    <pre id="type-docstr"></pre>
    Fields: <span id="type-fields">[p gs _meta]</span><br />
    Protocols: <span id="type-protocols"><a href="clojure.core.match-api.html#clojure.core.match.protocols/IPatternCompile">clojure.core.match.protocols/IPatternCompile</a>, <a href="clojure.core.match-api.html#clojure.core.match.protocols/ISpecializeMatrix">clojure.core.match.protocols/ISpecializeMatrix</a></span><br />
    Interfaces: <span id="type-interfaces">clojure.lang.ILookup, clojure.lang.IObj</span><br />
  </div><div id="type-entry">
    <br />
    <hr />
    <h2 id="clojure.core.match/LeafNode">LeafNode</h2>
    <span id="type-type">record</span><br />
    <pre id="type-docstr"></pre>
    Fields: <span id="type-fields">[value bindings]</span><br />
    Protocols: <span id="type-protocols"><a href="clojure.core.match-api.html#clojure.core.match.protocols/INodeCompile">clojure.core.match.protocols/INodeCompile</a></span><br />
    Interfaces: <span id="type-interfaces">clojure.lang.IHashEq, clojure.lang.IKeywordLookup, clojure.lang.ILookup, clojure.lang.IObj, clojure.lang.IPersistentMap, java.io.Serializable, java.util.Map</span><br />
  </div><div id="type-entry">
    <br />
    <hr />
    <h2 id="clojure.core.match/LiteralPattern">LiteralPattern</h2>
    <span id="type-type">type</span><br />
    <pre id="type-docstr"></pre>
    Fields: <span id="type-fields">[l _meta]</span><br />
    Protocols: <span id="type-protocols"><a href="clojure.core.match-api.html#clojure.core.match.protocols/IPatternCompile">clojure.core.match.protocols/IPatternCompile</a></span><br />
    Interfaces: <span id="type-interfaces">clojure.lang.ILookup, clojure.lang.IObj</span><br />
  </div><div id="type-entry">
    <br />
    <hr />
    <h2 id="clojure.core.match/MapKeyPattern">MapKeyPattern</h2>
    <span id="type-type">record</span><br />
    <pre id="type-docstr"></pre>
    Fields: <span id="type-fields">[p]</span><br />
    Protocols: <span id="type-protocols"><a href="clojure.core.match-api.html#clojure.core.match.protocols/IPatternCompile">clojure.core.match.protocols/IPatternCompile</a>, <a href="clojure.core.match-api.html#clojure.core.match.protocols/ISpecializeMatrix">clojure.core.match.protocols/ISpecializeMatrix</a></span><br />
    Interfaces: <span id="type-interfaces">clojure.core.match.protocols.IExistentialPattern, clojure.lang.IHashEq, clojure.lang.IKeywordLookup, clojure.lang.ILookup, clojure.lang.IObj, clojure.lang.IPersistentMap, java.io.Serializable, java.util.Map</span><br />
  </div><div id="type-entry">
    <br />
    <hr />
    <h2 id="clojure.core.match/MapPattern">MapPattern</h2>
    <span id="type-type">type</span><br />
    <pre id="type-docstr"></pre>
    Fields: <span id="type-fields">[m _meta]</span><br />
    Protocols: <span id="type-protocols"><a href="clojure.core.match-api.html#clojure.core.match.protocols/IPatternCompile">clojure.core.match.protocols/IPatternCompile</a>, <a href="clojure.core.match-api.html#clojure.core.match.protocols/ISpecializeMatrix">clojure.core.match.protocols/ISpecializeMatrix</a></span><br />
    Interfaces: <span id="type-interfaces">clojure.lang.ILookup, clojure.lang.IObj</span><br />
  </div><div id="type-entry">
    <br />
    <hr />
    <h2 id="clojure.core.match/OrPattern">OrPattern</h2>
    <span id="type-type">type</span><br />
    <pre id="type-docstr"></pre>
    Fields: <span id="type-fields">[ps _meta]</span><br />
    Protocols: <span id="type-protocols"><a href="clojure.core.match-api.html#clojure.core.match.protocols/ISpecializeMatrix">clojure.core.match.protocols/ISpecializeMatrix</a></span><br />
    Interfaces: <span id="type-interfaces">clojure.core.match.protocols.IPseudoPattern, clojure.lang.ILookup, clojure.lang.IObj</span><br />
  </div><div id="type-entry">
    <br />
    <hr />
    <h2 id="clojure.core.match/PatternMatrix">PatternMatrix</h2>
    <span id="type-type">record</span><br />
    <pre id="type-docstr"></pre>
    Fields: <span id="type-fields">[rows ocrs]</span><br />
    Protocols: <span id="type-protocols"><a href="clojure.core.match-api.html#clojure.core.match.protocols/IVecMod">clojure.core.match.protocols/IVecMod</a></span><br />
    Interfaces: <span id="type-interfaces">clojure.lang.IHashEq, clojure.lang.IKeywordLookup, clojure.lang.ILookup, clojure.lang.IObj, clojure.lang.IPersistentMap, java.io.Serializable, java.util.Map</span><br />
  </div><div id="type-entry">
    <br />
    <hr />
    <h2 id="clojure.core.match/PatternRow">PatternRow</h2>
    <span id="type-type">type</span><br />
    <pre id="type-docstr"></pre>
    Fields: <span id="type-fields">[ps action bindings]</span><br />
    Protocols: <span id="type-protocols"><a href="clojure.core.match-api.html#clojure.core.match.protocols/IVecMod">clojure.core.match.protocols/IVecMod</a></span><br />
    Interfaces: <span id="type-interfaces">clojure.lang.Associative, clojure.lang.IFn, clojure.lang.ILookup, clojure.lang.IPersistentCollection, clojure.lang.ISeq, clojure.lang.Indexed</span><br />
  </div><div id="type-entry">
    <br />
    <hr />
    <h2 id="clojure.core.match/PredicatePattern">PredicatePattern</h2>
    <span id="type-type">type</span><br />
    <pre id="type-docstr"></pre>
    Fields: <span id="type-fields">[p gs _meta]</span><br />
    Protocols: <span id="type-protocols"><a href="clojure.core.match-api.html#clojure.core.match.protocols/IPatternCompile">clojure.core.match.protocols/IPatternCompile</a>, <a href="clojure.core.match-api.html#clojure.core.match.protocols/ISpecializeMatrix">clojure.core.match.protocols/ISpecializeMatrix</a></span><br />
    Interfaces: <span id="type-interfaces">clojure.lang.ILookup, clojure.lang.IObj</span><br />
  </div><div id="type-entry">
    <br />
    <hr />
    <h2 id="clojure.core.match/RestPattern">RestPattern</h2>
    <span id="type-type">record</span><br />
    <pre id="type-docstr"></pre>
    Fields: <span id="type-fields">[p]</span><br />
    Protocols: <span id="type-protocols"></span><br />
    Interfaces: <span id="type-interfaces">clojure.lang.IHashEq, clojure.lang.IKeywordLookup, clojure.lang.ILookup, clojure.lang.IObj, clojure.lang.IPersistentMap, java.io.Serializable, java.util.Map</span><br />
  </div><div id="type-entry">
    <br />
    <hr />
    <h2 id="clojure.core.match/SeqPattern">SeqPattern</h2>
    <span id="type-type">type</span><br />
    <pre id="type-docstr"></pre>
    Fields: <span id="type-fields">[s _meta]</span><br />
    Protocols: <span id="type-protocols"><a href="clojure.core.match-api.html#clojure.core.match.protocols/IPatternCompile">clojure.core.match.protocols/IPatternCompile</a>, <a href="clojure.core.match-api.html#clojure.core.match.protocols/ISpecializeMatrix">clojure.core.match.protocols/ISpecializeMatrix</a></span><br />
    Interfaces: <span id="type-interfaces">clojure.lang.ILookup, clojure.lang.IObj</span><br />
  </div><div id="type-entry">
    <br />
    <hr />
    <h2 id="clojure.core.match/SwitchNode">SwitchNode</h2>
    <span id="type-type">record</span><br />
    <pre id="type-docstr"></pre>
    Fields: <span id="type-fields">[occurrence cases default]</span><br />
    Protocols: <span id="type-protocols"><a href="clojure.core.match-api.html#clojure.core.match.protocols/INodeCompile">clojure.core.match.protocols/INodeCompile</a></span><br />
    Interfaces: <span id="type-interfaces">clojure.lang.IHashEq, clojure.lang.IKeywordLookup, clojure.lang.ILookup, clojure.lang.IObj, clojure.lang.IPersistentMap, java.io.Serializable, java.util.Map</span><br />
  </div><div id="type-entry">
    <br />
    <hr />
    <h2 id="clojure.core.match/VectorPattern">VectorPattern</h2>
    <span id="type-type">type</span><br />
    <pre id="type-docstr"></pre>
    Fields: <span id="type-fields">[v t size offset rest? _meta]</span><br />
    Protocols: <span id="type-protocols"><a href="clojure.core.match-api.html#clojure.core.match.protocols/IContainsRestPattern">clojure.core.match.protocols/IContainsRestPattern</a>, <a href="clojure.core.match-api.html#clojure.core.match.protocols/IPatternCompile">clojure.core.match.protocols/IPatternCompile</a>, <a href="clojure.core.match-api.html#clojure.core.match.protocols/ISpecializeMatrix">clojure.core.match.protocols/ISpecializeMatrix</a>, <a href="clojure.core.match-api.html#clojure.core.match.protocols/IVectorPattern">clojure.core.match.protocols/IVectorPattern</a></span><br />
    Interfaces: <span id="type-interfaces">clojure.lang.ILookup, clojure.lang.IObj</span><br />
  </div><div id="type-entry">
    <br />
    <hr />
    <h2 id="clojure.core.match/WildcardPattern">WildcardPattern</h2>
    <span id="type-type">type</span><br />
    <pre id="type-docstr"></pre>
    Fields: <span id="type-fields">[sym named _meta]</span><br />
    Protocols: <span id="type-protocols"></span><br />
    Interfaces: <span id="type-interfaces">clojure.lang.ILookup, clojure.lang.IObj</span><br />
  </div>
</div>
<div id="var-section">
  <p></p>
  <h2>Public Variables and Functions</h2>
  <div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.match/*match-lookup*">*match-lookup*</h2>
    <span id="var-type">dynamic var</span><br />
    <pre id="var-usage"></pre>
    <pre id="var-docstr">Allow map matching syntax to check for IMatchLookup</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.match/blob/fc54caaa0f37862eb4e3b54dab9fc0d9ad173d7e/src/main/clojure/clojure/core/match.clj#L65">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.match/*no-backtrack*">*no-backtrack*</h2>
    <span id="var-type">dynamic var</span><br />
    <pre id="var-usage"></pre>
    <pre id="var-docstr">Flag to optimize performance over code size.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.match/blob/fc54caaa0f37862eb4e3b54dab9fc0d9ad173d7e/src/main/clojure/clojure/core/match.clj#L79">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.match/*recur-present*">*recur-present*</h2>
    <span id="var-type">dynamic var</span><br />
    <pre id="var-usage"></pre>
    <pre id="var-docstr">In the presence of recur we cannot apply code size optimizations</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.match/blob/fc54caaa0f37862eb4e3b54dab9fc0d9ad173d7e/src/main/clojure/clojure/core/match.clj#L75">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.match/*syntax-check*">*syntax-check*</h2>
    <span id="var-type">dynamic var</span><br />
    <pre id="var-usage"></pre>
    <pre id="var-docstr">Enable syntax check of match macros</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.match/blob/fc54caaa0f37862eb4e3b54dab9fc0d9ad173d7e/src/main/clojure/clojure/core/match.clj#L54">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.match/*vector-type*">*vector-type*</h2>
    <span id="var-type">dynamic var</span><br />
    <pre id="var-usage"></pre>
    <pre id="var-docstr">Default vector type. Can be rebound allowing emission of
custom inline code for vector patterns, for example
type-hinted primitive array operations</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.match/blob/fc54caaa0f37862eb4e3b54dab9fc0d9ad173d7e/src/main/clojure/clojure/core/match.clj#L69">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.match/-&gt;AppPattern">-&gt;AppPattern</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (-&gt;AppPattern p form _meta)
</pre>
    <pre id="var-docstr">Positional factory function for class clojure.core.match.AppPattern.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.match/blob/fc54caaa0f37862eb4e3b54dab9fc0d9ad173d7e/src/main/clojure/clojure/core/match.clj#L1577">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.match/-&gt;BindNode">-&gt;BindNode</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (-&gt;BindNode bindings node)
</pre>
    <pre id="var-docstr">Positional factory function for class clojure.core.match.BindNode.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.match/blob/fc54caaa0f37862eb4e3b54dab9fc0d9ad173d7e/src/main/clojure/clojure/core/match.clj#L420">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.match/-&gt;FailNode">-&gt;FailNode</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (-&gt;FailNode)
</pre>
    <pre id="var-docstr">Positional factory function for class clojure.core.match.FailNode.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.match/blob/fc54caaa0f37862eb4e3b54dab9fc0d9ad173d7e/src/main/clojure/clojure/core/match.clj#L404">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.match/-&gt;GuardPattern">-&gt;GuardPattern</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (-&gt;GuardPattern p gs _meta)
</pre>
    <pre id="var-docstr">Positional factory function for class clojure.core.match.GuardPattern.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.match/blob/fc54caaa0f37862eb4e3b54dab9fc0d9ad173d7e/src/main/clojure/clojure/core/match.clj#L1490">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.match/-&gt;LeafNode">-&gt;LeafNode</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (-&gt;LeafNode value bindings)
</pre>
    <pre id="var-docstr">Positional factory function for class clojure.core.match.LeafNode.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.match/blob/fc54caaa0f37862eb4e3b54dab9fc0d9ad173d7e/src/main/clojure/clojure/core/match.clj#L371">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.match/-&gt;LiteralPattern">-&gt;LiteralPattern</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (-&gt;LiteralPattern l _meta)
</pre>
    <pre id="var-docstr">Positional factory function for class clojure.core.match.LiteralPattern.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.match/blob/fc54caaa0f37862eb4e3b54dab9fc0d9ad173d7e/src/main/clojure/clojure/core/match.clj#L906">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.match/-&gt;MapKeyPattern">-&gt;MapKeyPattern</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (-&gt;MapKeyPattern p)
</pre>
    <pre id="var-docstr">Positional factory function for class clojure.core.match.MapKeyPattern.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.match/blob/fc54caaa0f37862eb4e3b54dab9fc0d9ad173d7e/src/main/clojure/clojure/core/match.clj#L1091">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.match/-&gt;MapPattern">-&gt;MapPattern</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (-&gt;MapPattern m _meta)
</pre>
    <pre id="var-docstr">Positional factory function for class clojure.core.match.MapPattern.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.match/blob/fc54caaa0f37862eb4e3b54dab9fc0d9ad173d7e/src/main/clojure/clojure/core/match.clj#L1195">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.match/-&gt;OrPattern">-&gt;OrPattern</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (-&gt;OrPattern ps _meta)
</pre>
    <pre id="var-docstr">Positional factory function for class clojure.core.match.OrPattern.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.match/blob/fc54caaa0f37862eb4e3b54dab9fc0d9ad173d7e/src/main/clojure/clojure/core/match.clj#L1433">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.match/-&gt;PatternMatrix">-&gt;PatternMatrix</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (-&gt;PatternMatrix rows ocrs)
</pre>
    <pre id="var-docstr">Positional factory function for class clojure.core.match.PatternMatrix.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.match/blob/fc54caaa0f37862eb4e3b54dab9fc0d9ad173d7e/src/main/clojure/clojure/core/match.clj#L813">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.match/-&gt;PatternRow">-&gt;PatternRow</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (-&gt;PatternRow ps action bindings)
</pre>
    <pre id="var-docstr">Positional factory function for class clojure.core.match.PatternRow.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.match/blob/fc54caaa0f37862eb4e3b54dab9fc0d9ad173d7e/src/main/clojure/clojure/core/match.clj#L265">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.match/-&gt;PredicatePattern">-&gt;PredicatePattern</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (-&gt;PredicatePattern p gs _meta)
</pre>
    <pre id="var-docstr">Positional factory function for class clojure.core.match.PredicatePattern.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.match/blob/fc54caaa0f37862eb4e3b54dab9fc0d9ad173d7e/src/main/clojure/clojure/core/match.clj#L1654">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.match/-&gt;RestPattern">-&gt;RestPattern</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (-&gt;RestPattern p)
</pre>
    <pre id="var-docstr">Positional factory function for class clojure.core.match.RestPattern.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.match/blob/fc54caaa0f37862eb4e3b54dab9fc0d9ad173d7e/src/main/clojure/clojure/core/match.clj#L1067">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.match/-&gt;SeqPattern">-&gt;SeqPattern</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (-&gt;SeqPattern s _meta)
</pre>
    <pre id="var-docstr">Positional factory function for class clojure.core.match.SeqPattern.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.match/blob/fc54caaa0f37862eb4e3b54dab9fc0d9ad173d7e/src/main/clojure/clojure/core/match.clj#L1010">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.match/-&gt;SwitchNode">-&gt;SwitchNode</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (-&gt;SwitchNode occurrence cases default)
</pre>
    <pre id="var-docstr">Positional factory function for class clojure.core.match.SwitchNode.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.match/blob/fc54caaa0f37862eb4e3b54dab9fc0d9ad173d7e/src/main/clojure/clojure/core/match.clj#L448">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.match/-&gt;VectorPattern">-&gt;VectorPattern</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (-&gt;VectorPattern v t size offset rest? _meta)
</pre>
    <pre id="var-docstr">Positional factory function for class clojure.core.match.VectorPattern.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.match/blob/fc54caaa0f37862eb4e3b54dab9fc0d9ad173d7e/src/main/clojure/clojure/core/match.clj#L1334">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.match/-&gt;WildcardPattern">-&gt;WildcardPattern</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (-&gt;WildcardPattern sym named _meta)
</pre>
    <pre id="var-docstr">Positional factory function for class clojure.core.match.WildcardPattern.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.match/blob/fc54caaa0f37862eb4e3b54dab9fc0d9ad173d7e/src/main/clojure/clojure/core/match.clj#L855">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.match/backtrack">backtrack</h2>
    <span id="var-type">var</span><br />
    <pre id="var-usage"></pre>
    <pre id="var-docstr">Pre-allocated exception used for backtracing</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.match/blob/fc54caaa0f37862eb4e3b54dab9fc0d9ad173d7e/src/main/clojure/clojure/core/match.clj#L83">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.match/emit-matrix">emit-matrix</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (emit-matrix vars clauses)
       (emit-matrix vars clauses default)
</pre>
    <pre id="var-docstr">Take the list of vars and sequence of unprocessed clauses and
return the pattern matrix. The pattern matrix contains the processed
pattern rows and the list of vars originally specified. Inserts
a last match - :else if provided by the user or a default match that
throws.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.match/blob/fc54caaa0f37862eb4e3b54dab9fc0d9ad173d7e/src/main/clojure/clojure/core/match.clj#L2039">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.match/emit-pattern">emit-pattern</h2>
    <span id="var-type">multimethod</span><br />
    <pre id="var-usage">No usage documentation available</pre>
    <pre id="var-docstr">Returns the corresponding pattern for the given syntax. Dispatches
on the class of its argument. For example, `[(:or 1 2) 2]` is dispatched
as clojure.lang.IPersistentVector</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.match/blob/fc54caaa0f37862eb4e3b54dab9fc0d9ad173d7e/src/main/clojure/clojure/core/match.clj#L1743">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.match/emit-pattern-for-syntax">emit-pattern-for-syntax</h2>
    <span id="var-type">multimethod</span><br />
    <pre id="var-usage">No usage documentation available</pre>
    <pre id="var-docstr">Handles patterns wrapped in the special list syntax. Dispatches
on the first or second keyword in the list. For example, the pattern 
`(:or 1 ...) is dispatches as :or, and `(1 :as a)` is dispatched by :as.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.match/blob/fc54caaa0f37862eb4e3b54dab9fc0d9ad173d7e/src/main/clojure/clojure/core/match.clj#L1819">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.match/empty-rows-case">empty-rows-case</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (empty-rows-case)
</pre>
    <pre id="var-docstr">Case 1: If there are no pattern rows to match, then matching always fails</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.match/blob/fc54caaa0f37862eb4e3b54dab9fc0d9ad173d7e/src/main/clojure/clojure/core/match.clj#L711">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.match/first-column-chosen-case">first-column-chosen-case</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (first-column-chosen-case matrix col ocrs)
</pre>
    <pre id="var-docstr">Case 3a: The first column is chosen. Compute and return a
switch/bind node with a default matrix case</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.match/blob/fc54caaa0f37862eb4e3b54dab9fc0d9ad173d7e/src/main/clojure/clojure/core/match.clj#L758">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.match/first-row-empty-case">first-row-empty-case</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (first-row-empty-case rows ocr)
</pre>
    <pre id="var-docstr">Case 2: If the first row is empty then matching always succeeds 
and yields the first action.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.match/blob/fc54caaa0f37862eb4e3b54dab9fc0d9ad173d7e/src/main/clojure/clojure/core/match.clj#L716">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.match/first-row-wildcards-case">first-row-wildcards-case</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (first-row-wildcards-case rows ocrs)
</pre>
    <pre id="var-docstr">Case 2: If the first row is constituted by wildcards then matching
matching always succeeds and yields the first action.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.match/blob/fc54caaa0f37862eb4e3b54dab9fc0d9ad173d7e/src/main/clojure/clojure/core/match.clj#L726">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.match/group-keywords">group-keywords</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (group-keywords pattern)
</pre>
    <pre id="var-docstr">Returns a pattern with pattern-keywords (:when and :as) properly
grouped.  The original pattern may use the 'flattened' syntax.
For example, a 'flattened' pattern row like [a b :when even?] is
grouped as [a (b :when even?)].</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.match/blob/fc54caaa0f37862eb4e3b54dab9fc0d9ad173d7e/src/main/clojure/clojure/core/match.clj#L1903">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.match/groupable?">groupable?</h2>
    <span id="var-type">multimethod</span><br />
    <pre id="var-usage">No usage documentation available</pre>
    <pre id="var-docstr">Determine if two patterns may be grouped together for simultaneous
testing.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.match/blob/fc54caaa0f37862eb4e3b54dab9fc0d9ad173d7e/src/main/clojure/clojure/core/match.clj#L247">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.match/map-&gt;BindNode">map-&gt;BindNode</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (map-&gt;BindNode m#)
</pre>
    <pre id="var-docstr">Factory function for class clojure.core.match.BindNode, taking a map of keywords to field values.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.match/blob/fc54caaa0f37862eb4e3b54dab9fc0d9ad173d7e/src/main/clojure/clojure/core/match.clj#L420">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.match/map-&gt;FailNode">map-&gt;FailNode</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (map-&gt;FailNode m#)
</pre>
    <pre id="var-docstr">Factory function for class clojure.core.match.FailNode, taking a map of keywords to field values.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.match/blob/fc54caaa0f37862eb4e3b54dab9fc0d9ad173d7e/src/main/clojure/clojure/core/match.clj#L404">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.match/map-&gt;LeafNode">map-&gt;LeafNode</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (map-&gt;LeafNode m#)
</pre>
    <pre id="var-docstr">Factory function for class clojure.core.match.LeafNode, taking a map of keywords to field values.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.match/blob/fc54caaa0f37862eb4e3b54dab9fc0d9ad173d7e/src/main/clojure/clojure/core/match.clj#L371">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.match/map-&gt;MapKeyPattern">map-&gt;MapKeyPattern</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (map-&gt;MapKeyPattern m#)
</pre>
    <pre id="var-docstr">Factory function for class clojure.core.match.MapKeyPattern, taking a map of keywords to field values.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.match/blob/fc54caaa0f37862eb4e3b54dab9fc0d9ad173d7e/src/main/clojure/clojure/core/match.clj#L1091">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.match/map-&gt;PatternMatrix">map-&gt;PatternMatrix</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (map-&gt;PatternMatrix m#)
</pre>
    <pre id="var-docstr">Factory function for class clojure.core.match.PatternMatrix, taking a map of keywords to field values.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.match/blob/fc54caaa0f37862eb4e3b54dab9fc0d9ad173d7e/src/main/clojure/clojure/core/match.clj#L813">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.match/map-&gt;RestPattern">map-&gt;RestPattern</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (map-&gt;RestPattern m#)
</pre>
    <pre id="var-docstr">Factory function for class clojure.core.match.RestPattern, taking a map of keywords to field values.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.match/blob/fc54caaa0f37862eb4e3b54dab9fc0d9ad173d7e/src/main/clojure/clojure/core/match.clj#L1067">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.match/map-&gt;SwitchNode">map-&gt;SwitchNode</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (map-&gt;SwitchNode m#)
</pre>
    <pre id="var-docstr">Factory function for class clojure.core.match.SwitchNode, taking a map of keywords to field values.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.match/blob/fc54caaa0f37862eb4e3b54dab9fc0d9ad173d7e/src/main/clojure/clojure/core/match.clj#L448">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.match/match">match</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (match vars &amp; clauses)
</pre>
    <pre id="var-docstr">Pattern match a row of occurrences. Take a vector of occurrences, vars.
Clause question-answer syntax is like `cond`. Questions must be
wrapped in a vector, with same arity as vars. Last question can be :else,
which expands to a row of wildcards. Optionally may take a single
var not wrapped in a vector, questions then need not be wrapped in a
vector.

Example:
(let [x 1
      y 2]
  (match [x y 3]
    [1 2 3] :answer1
    :else :default-answer))</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.match/blob/fc54caaa0f37862eb4e3b54dab9fc0d9ad173d7e/src/main/clojure/clojure/core/match.clj#L2101">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.match/matchm">matchm</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (matchm vars &amp; clauses)
</pre>
    <pre id="var-docstr">Same as match but supports IMatchLookup when
matching maps.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.match/blob/fc54caaa0f37862eb4e3b54dab9fc0d9ad173d7e/src/main/clojure/clojure/core/match.clj#L2135">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.match/other-column-chosen-case">other-column-chosen-case</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (other-column-chosen-case matrix col)
</pre>
    <pre id="var-docstr">Case 3b: A column other than the first is chosen. Swap column 
col with the first column and compile the result</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.match/blob/fc54caaa0f37862eb4e3b54dab9fc0d9ad173d7e/src/main/clojure/clojure/core/match.clj#L781">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.match/process-vars">process-vars</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (process-vars vars)
</pre>
    <pre id="var-docstr">Process the vars for the pattern matrix. If user provides an
expression, create a var and annotate via metadata with the
original expression.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.match/blob/fc54caaa0f37862eb4e3b54dab9fc0d9ad173d7e/src/main/clojure/clojure/core/match.clj#L2027">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.match/to-pattern-row">to-pattern-row</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (to-pattern-row pat action)
</pre>
    <pre id="var-docstr">Take an unprocessed pattern expression and an action expression and return
a pattern row of the processed pattern expression plus the action epxression.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.match/blob/fc54caaa0f37862eb4e3b54dab9fc0d9ad173d7e/src/main/clojure/clojure/core/match.clj#L1911">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.match/to-source">to-source</h2>
    <span id="var-type">multimethod</span><br />
    <pre id="var-usage">No usage documentation available</pre>
    <pre id="var-docstr">Returns a Clojure form that, when executed, is truthy if the
pattern matches the occurrence. Dispatches on the `type` of the
pattern. For instance, a literal pattern might return `(= ~(:pattern
pattern) ~ocr)`, using `=` to test for a match.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.match/blob/fc54caaa0f37862eb4e3b54dab9fc0d9ad173d7e/src/main/clojure/clojure/core/match.clj#L1736">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.match/wildcards-and-duplicates">wildcards-and-duplicates</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (wildcards-and-duplicates patterns)
</pre>
    <pre id="var-docstr">Returns a vector of two elements: the set of all wildcards and the 
set of duplicate wildcards.  The underbar _ is excluded from both.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.match/blob/fc54caaa0f37862eb4e3b54dab9fc0d9ad173d7e/src/main/clojure/clojure/core/match.clj#L1918">Source</a>
  </div>
</div>

<br />
<h2 id="clojure.core.match.java">clojure.core.match.java</h2>
<pre id="namespace-docstr"></pre>


<br />


<div id="var-section">
  <p></p>
  <h2>Public Variables and Functions</h2>
  <div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.match.java/bean-match">bean-match</h2>
    <span id="var-type">macro</span><br />
    <pre id="var-usage">Usage: (bean-match class)
</pre>
    <pre id="var-docstr">Generate an implementation of match.core/IMatchLookup for a Java bean.
Accessor method names are mapped to keys like this:

  isVisible       -&gt; :visible?
  getText         -&gt; :text
  getAbsolutePath -&gt; :absolute-path 
  isFUD           -&gt; :fud?
  getFUDFactor    -&gt; :fud-factor

</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.match/blob/ec934828e9b231023ebaa223a22e2097f7b0915c/src/main/clojure/clojure/core/match/java.clj#L29">Source</a>
  </div>
</div>

<br />
<h2 id="clojure.core.match.protocols">clojure.core.match.protocols</h2>
<pre id="namespace-docstr"></pre>


<br />
<div id="proto-section">
  <p></p>
  <h2>Protocols</h2>
  <div id="proto-entry">
    <br />
    <hr />
    <h2 id="clojure.core.match.protocols/IMatchLookup">IMatchLookup</h2>
    <span id="proto-type">Protocol</span><br />
    <pre id="proto-docstr">Allows arbitrary objects to act like a map-like object when pattern
matched. Avoid extending this directly for Java Beans, see
`match.java/bean-match`.</pre>
    Known implementations: <span id="proto-impls">clojure.lang.ILookup, java.util.Date</span>
    <div id="proto-var-entry">
      <br />
      <h3 id="clojure.core.match.protocols/val-at">val-at</h3>
      <span id="var-type">function</span><br />
      <pre id="var-usage">Usage: (val-at this k not-found)
</pre>
      <pre id="var-docstr"></pre>
      <pre id="var-specs"></pre>
      
      
      
    </div>
    
    
    <a id="proto-source" href="https://github.com/clojure/core.match/blob/ec934828e9b231023ebaa223a22e2097f7b0915c/src/main/clojure/clojure/core/match/protocols.clj#L20">Source</a>
  </div>
</div>



<br />
<h2 id="clojure.core.match.regex">clojure.core.match.regex</h2>
<pre id="namespace-docstr"></pre>


<br />

<div id="type-section">
  <p></p>
  <h2>Types</h2>
  <div id="type-entry">
    <br />
    <hr />
    <h2 id="clojure.core.match.regex/RegexPattern">RegexPattern</h2>
    <span id="type-type">record</span><br />
    <pre id="type-docstr"></pre>
    Fields: <span id="type-fields">[regex]</span><br />
    Protocols: <span id="type-protocols"></span><br />
    Interfaces: <span id="type-interfaces">clojure.lang.IHashEq, clojure.lang.IKeywordLookup, clojure.lang.ILookup, clojure.lang.IObj, clojure.lang.IPersistentMap, java.io.Serializable, java.util.Map</span><br />
  </div>
</div>
<div id="var-section">
  <p></p>
  <h2>Public Variables and Functions</h2>
  <div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.match.regex/-&gt;RegexPattern">-&gt;RegexPattern</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (-&gt;RegexPattern regex)
</pre>
    <pre id="var-docstr">Positional factory function for class clojure.core.match.regex.RegexPattern.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.match/blob/ec934828e9b231023ebaa223a22e2097f7b0915c/src/main/clojure/clojure/core/match/regex.clj#L23">Source</a>
  </div><div id="var-entry">
    <br />
    <hr />
    <h2 id="clojure.core.match.regex/map-&gt;RegexPattern">map-&gt;RegexPattern</h2>
    <span id="var-type">function</span><br />
    <pre id="var-usage">Usage: (map-&gt;RegexPattern m#)
</pre>
    <pre id="var-docstr">Factory function for class clojure.core.match.regex.RegexPattern, taking a map of keywords to field values.</pre>
    <pre id="var-specs"></pre>
    
    
    <a id="var-source" href="https://github.com/clojure/core.match/blob/ec934828e9b231023ebaa223a22e2097f7b0915c/src/main/clojure/clojure/core/match/regex.clj#L23">Source</a>
  </div>
</div>


</div>
              </div>
            </div>
          </div>
	</div>
	<div id="foot">
	  <div id="copyright" style="text-align: center;">Copyright 2007-2023 by Rich Hickey and the various contributors</div>
	</div>
      </div>
      <div id="DesignedBy">Logo &amp; site design by <a href="http://www.tomhickey.com" title="Visit Tom Hickey's website.">Tom Hickey</a>.<br />
      Clojure auto-documentation system by Tom Faulhaber.</div>
    </div>
    <!-- /AllContentContainer -->
  </body>

</html>